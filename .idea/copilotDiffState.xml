<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/.github/CODEOWNERS">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/CODEOWNERS" />
              <option name="updatedContent" value="# CODEOWNERS - adjust GitHub handles as needed&#10;# Syntax: pattern  owner1  owner2&#10;&#10;*       @your-org/maintainers&#10;/app/** @your-org/android-leads&#10;/sdk/** @your-org/native-leads&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.github/FUNDING.yml">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/FUNDING.yml" />
              <option name="updatedContent" value="# Optional funding configuration â€“ customize or remove&#10;# github: your-org-or-user&#10;# patreon: your-id&#10;# open_collective: your-collective&#10;# ko_fi: your-id&#10;# liberapay: your-id&#10;# issuehunt: your-id&#10;# thanks_dev: your-id&#10;# custom: ['https://your.custom.link']&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/.github/ISSUE_TEMPLATE/bug_report.md">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/.github/ISSUE_TEMPLATE/bug_report.md" />
              <option name="updatedContent" value="---&#10;name: Bug report&#10;about: Report a reproducible problem&#10;labels: bug&#10;---&#10;&#10;## Describe the bug&#10;A clear and concise description.&#10;&#10;## Steps to reproduce&#10;1. Go to '...'&#10;2. Tap '...'&#10;3. Observe '...'&#10;&#10;## Expected behavior&#10;What you expected to happen.&#10;&#10;## Screenshots / Logs&#10;(If applicable)&#10;&#10;## Device / Environment&#10;- Device: [e.g. Pixel 8]&#10;- Android Version: [e.g. 14]&#10;- Build Variant: [debug/release]&#10;&#10;## Additional context&#10;Add any other context about the problem here.&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/build.gradle.kts" />
              <option name="originalContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.kotlin.serialization)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.cosc3001&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.cosc3001&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    // Read Supabase config from gradle properties with environment fallback&#10;    val supabaseUrl = providers.gradleProperty(&quot;SUPABASE_URL&quot;)&#10;        .orElse(providers.environmentVariable(&quot;SUPABASE_URL&quot;))&#10;        .orNull ?: &quot;&quot;&#10;    val supabaseAnonKey = providers.gradleProperty(&quot;SUPABASE_ANON_KEY&quot;)&#10;        .orElse(providers.environmentVariable(&quot;SUPABASE_ANON_KEY&quot;))&#10;        .orNull ?: &quot;&quot;&#10;    // New: Gemini API Key + optional model name (defaults to gemini-2.0-flash)&#10;    val geminiApiKey = providers.gradleProperty(&quot;GEMINI_API_KEY&quot;)&#10;        .orElse(providers.environmentVariable(&quot;GEMINI_API_KEY&quot;))&#10;        .orNull ?: &quot;&quot;&#10;    val geminiModel = providers.gradleProperty(&quot;GEMINI_MODEL&quot;)&#10;        .orElse(providers.environmentVariable(&quot;GEMINI_MODEL&quot;))&#10;        .orNull ?: &quot;gemini-2.0-flash&quot;&#10;&#10;    buildTypes {&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_URL&quot;, &quot;\&quot;$supabaseUrl\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_ANON_KEY&quot;, &quot;\&quot;$supabaseAnonKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;$geminiApiKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_MODEL&quot;, &quot;\&quot;$geminiModel\&quot;&quot;)&#10;        }&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_URL&quot;, &quot;\&quot;$supabaseUrl\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_ANON_KEY&quot;, &quot;\&quot;$supabaseAnonKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;$geminiApiKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_MODEL&quot;, &quot;\&quot;$geminiModel\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    sourceSets {&#10;        getByName(&quot;main&quot;) {&#10;            jniLibs.srcDirs(&quot;libs&quot;)&#10;            // Added to include existing png under src/assets as an Android asset folder&#10;            assets.srcDirs(&quot;src/assets&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;    implementation(libs.androidx.compose.material.icons.extended)&#10;&#10;    // AppCompat for AppCompatActivity&#10;    implementation(libs.androidx.appcompat)&#10;&#10;    // ARCore&#10;    implementation(libs.core)&#10;&#10;    // SceneView&#10;    implementation(libs.arsceneview)&#10;    implementation(libs.sceneview)&#10;&#10;    // ZXing for QR code scanning&#10;    implementation(libs.zxing.android.embedded)&#10;    implementation(libs.zxing.core)&#10;&#10;    // OpenCV for pose estimation&#10;    implementation(project(&quot;:sdk&quot;))&#10;    implementation(libs.litert)&#10;&#10;    // Ktor client stack via catalog&#10;    implementation(libs.ktor.client.core)&#10;    implementation(libs.ktor.client.okhttp)&#10;    // Optional Ktor extras kept commented&#10;    //implementation(libs.ktor.client.logging)&#10;    //implementation(libs.ktor.client.content.negotiation)&#10;    //implementation(libs.ktor.serialization.kotlinx.json)&#10;    //implementation(libs.kotlinx.serialization.json)&#10;&#10;    // --- Supabase (using official BOM at a known published version 2.4.0) ---&#10;    implementation(platform(&quot;io.github.jan-tennert.supabase:bom:2.4.0&quot;))&#10;    implementation(&quot;io.github.jan-tennert.supabase:postgrest-kt&quot;)&#10;    implementation(&quot;io.github.jan-tennert.supabase:storage-kt&quot;)&#10;    implementation(&quot;io.github.jan-tennert.supabase:gotrue-kt&quot;)&#10;&#10;    // --- Ktor stack aligned to Supabase 2.4.0 expectations (2.3.3) ---&#10;    implementation(&quot;io.ktor:ktor-client-android:2.3.3&quot;)&#10;    implementation(&quot;io.ktor:ktor-client-logging:2.3.3&quot;)&#10;    implementation(&quot;io.ktor:ktor-client-content-negotiation:2.3.3&quot;)&#10;    implementation(&quot;io.ktor:ktor-serialization-kotlinx-json:2.3.3&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}&#10;" />
              <option name="updatedContent" value="plugins {&#10;    alias(libs.plugins.android.application)&#10;    alias(libs.plugins.kotlin.android)&#10;    alias(libs.plugins.kotlin.compose)&#10;    alias(libs.plugins.kotlin.serialization)&#10;}&#10;&#10;android {&#10;    namespace = &quot;com.example.cosc3001&quot;&#10;    compileSdk = 36&#10;&#10;    defaultConfig {&#10;        applicationId = &quot;com.example.cosc3001&quot;&#10;        minSdk = 26&#10;        targetSdk = 36&#10;        versionCode = 1&#10;        versionName = &quot;1.0&quot;&#10;&#10;        testInstrumentationRunner = &quot;androidx.test.runner.AndroidJUnitRunner&quot;&#10;    }&#10;&#10;    // Read Supabase config from gradle properties with environment fallback&#10;    val supabaseUrl = providers.gradleProperty(&quot;SUPABASE_URL&quot;)&#10;        .orElse(providers.environmentVariable(&quot;SUPABASE_URL&quot;))&#10;        .orNull ?: &quot;&quot;&#10;    val supabaseAnonKey = providers.gradleProperty(&quot;SUPABASE_ANON_KEY&quot;)&#10;        .orElse(providers.environmentVariable(&quot;SUPABASE_ANON_KEY&quot;))&#10;        .orNull ?: &quot;&quot;&#10;    // New: Gemini API Key + optional model name (defaults to gemini-2.0-flash)&#10;    val geminiApiKey = providers.gradleProperty(&quot;GEMINI_API_KEY&quot;)&#10;        .orElse(providers.environmentVariable(&quot;GEMINI_API_KEY&quot;))&#10;        .orNull ?: &quot;&quot;&#10;    val geminiModel = providers.gradleProperty(&quot;GEMINI_MODEL&quot;)&#10;        .orElse(providers.environmentVariable(&quot;GEMINI_MODEL&quot;))&#10;        .orNull ?: &quot;gemini-2.0-flash&quot;&#10;&#10;    buildTypes {&#10;        debug {&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_URL&quot;, &quot;\&quot;$supabaseUrl\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_ANON_KEY&quot;, &quot;\&quot;$supabaseAnonKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;$geminiApiKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_MODEL&quot;, &quot;\&quot;$geminiModel\&quot;&quot;)&#10;        }&#10;        release {&#10;            isMinifyEnabled = false&#10;            proguardFiles(&#10;                getDefaultProguardFile(&quot;proguard-android-optimize.txt&quot;),&#10;                &quot;proguard-rules.pro&quot;&#10;            )&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_URL&quot;, &quot;\&quot;$supabaseUrl\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;SUPABASE_ANON_KEY&quot;, &quot;\&quot;$supabaseAnonKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_API_KEY&quot;, &quot;\&quot;$geminiApiKey\&quot;&quot;)&#10;            buildConfigField(&quot;String&quot;, &quot;GEMINI_MODEL&quot;, &quot;\&quot;$geminiModel\&quot;&quot;)&#10;        }&#10;    }&#10;    compileOptions {&#10;        sourceCompatibility = JavaVersion.VERSION_17&#10;        targetCompatibility = JavaVersion.VERSION_17&#10;    }&#10;    kotlinOptions {&#10;        jvmTarget = &quot;17&quot;&#10;    }&#10;    buildFeatures {&#10;        compose = true&#10;        buildConfig = true&#10;    }&#10;    sourceSets {&#10;        getByName(&quot;main&quot;) {&#10;            jniLibs.srcDirs(&quot;libs&quot;)&#10;            // Added to include existing png under src/assets as an Android asset folder&#10;            assets.srcDirs(&quot;src/assets&quot;)&#10;        }&#10;    }&#10;}&#10;&#10;dependencies {&#10;&#10;    implementation(libs.androidx.core.ktx)&#10;    implementation(libs.androidx.lifecycle.runtime.ktx)&#10;    implementation(libs.androidx.activity.compose)&#10;    implementation(platform(libs.androidx.compose.bom))&#10;    implementation(libs.androidx.compose.ui)&#10;    implementation(libs.androidx.compose.ui.graphics)&#10;    implementation(libs.androidx.compose.ui.tooling.preview)&#10;    implementation(libs.androidx.compose.material3)&#10;    implementation(libs.androidx.compose.material.icons.extended)&#10;&#10;    // AppCompat for AppCompatActivity&#10;    implementation(libs.androidx.appcompat)&#10;&#10;    // ARCore&#10;    implementation(libs.core)&#10;&#10;    // SceneView&#10;    implementation(libs.arsceneview)&#10;    implementation(libs.sceneview)&#10;&#10;    // ZXing for QR code scanning&#10;    implementation(libs.zxing.android.embedded)&#10;    implementation(libs.zxing.core)&#10;&#10;    // OpenCV for pose estimation&#10;    implementation(project(&quot;:sdk&quot;))&#10;    implementation(libs.litert)&#10;&#10;    // Ktor client stack via catalog&#10;    implementation(libs.ktor.client.core)&#10;    implementation(libs.ktor.client.okhttp)&#10;    // Optional Ktor extras kept commented&#10;    //implementation(libs.ktor.client.logging)&#10;    //implementation(libs.ktor.client.content.negotiation)&#10;    //implementation(libs.ktor.serialization.kotlinx.json)&#10;    //implementation(libs.kotlinx.serialization.json)&#10;&#10;    // --- Supabase (using official BOM at a known published version 2.4.0) ---&#10;    implementation(platform(&quot;io.github.jan-tennert.supabase:bom:2.4.0&quot;))&#10;    implementation(&quot;io.github.jan-tennert.supabase:postgrest-kt&quot;)&#10;    implementation(&quot;io.github.jan-tennert.supabase:storage-kt&quot;)&#10;    implementation(&quot;io.github.jan-tennert.supabase:gotrue-kt&quot;)&#10;&#10;    // --- Ktor stack aligned to Supabase 2.4.0 expectations (2.3.3) ---&#10;    implementation(&quot;io.ktor:ktor-client-android:2.3.3&quot;)&#10;    implementation(&quot;io.ktor:ktor-client-logging:2.3.3&quot;)&#10;    implementation(&quot;io.ktor:ktor-client-content-negotiation:2.3.3&quot;)&#10;    implementation(&quot;io.ktor:ktor-serialization-kotlinx-json:2.3.3&quot;)&#10;&#10;    testImplementation(libs.junit)&#10;    androidTestImplementation(libs.androidx.junit)&#10;    androidTestImplementation(libs.androidx.espresso.core)&#10;    androidTestImplementation(platform(libs.androidx.compose.bom))&#10;    androidTestImplementation(libs.androidx.compose.ui.test.junit4)&#10;    debugImplementation(libs.androidx.compose.ui.tooling)&#10;    debugImplementation(libs.androidx.compose.ui.test.manifest)&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/example/cosc3001/ChatBotViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/example/cosc3001/ChatBotViewModel.kt" />
              <option name="originalContent" value="package com.example.cosc3001&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Simple chat message representation for the in-app temporary chatbot overlay.&#10; */&#10;data class ChatMessage(&#10;    val id: Long,&#10;    val role: Role,&#10;    val text: String&#10;) {&#10;    enum class Role { User, Assistant, System }&#10;}&#10;&#10;class ChatBotViewModel(&#10;    private val backend: ChatBackend,&#10;    private val apiKeyPresent: Boolean&#10;) : ViewModel() {&#10;&#10;    private val _messages = MutableStateFlow&lt;List&lt;ChatMessage&gt;&gt;(emptyList())&#10;    val messages: StateFlow&lt;List&lt;ChatMessage&gt;&gt; = _messages.asStateFlow()&#10;&#10;    private val _sending = MutableStateFlow(false)&#10;    val sending: StateFlow&lt;Boolean&gt; = _sending.asStateFlow()&#10;&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()&#10;&#10;    private var counter = 0L&#10;&#10;    init {&#10;        if (!apiKeyPresent) {&#10;            appendSystem(&quot;Chat service key missing. Responses are lightweight local hints only.&quot;)&#10;        } else {&#10;            appendSystem(&quot;Chat assistant ready. This overlay is temporary and not persisted.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun nextId() = ++counter&#10;&#10;    private fun append(role: ChatMessage.Role, text: String) {&#10;        _messages.value = _messages.value + ChatMessage(nextId(), role, text)&#10;    }&#10;&#10;    private fun appendSystem(text: String) = append(ChatMessage.Role.System, text)&#10;&#10;    fun send(userInput: String) {&#10;        val trimmed = userInput.trim()&#10;        if (trimmed.isEmpty() || _sending.value) return&#10;        append(ChatMessage.Role.User, trimmed)&#10;        _sending.value = true&#10;        _error.value = null&#10;        viewModelScope.launch {&#10;            try {&#10;                val reply = backend.sendMessage(trimmed)&#10;                append(ChatMessage.Role.Assistant, reply)&#10;            } catch (t: Throwable) {&#10;                _error.value = t.message ?: t::class.simpleName ?: &quot;error&quot;&#10;                append(ChatMessage.Role.System, &quot;Error: ${_error.value}&quot;)&#10;            } finally {&#10;                _sending.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() { _error.value = null }&#10;}&#10;" />
              <option name="updatedContent" value="package com.example.cosc3001&#10;&#10;import androidx.lifecycle.ViewModel&#10;import androidx.lifecycle.viewModelScope&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Simple chat message representation for the in-app temporary chatbot overlay.&#10; */&#10;data class ChatMessage(&#10;    val id: Long,&#10;    val role: Role,&#10;    val text: String&#10;) {&#10;    enum class Role { User, Assistant, System }&#10;}&#10;&#10;class ChatBotViewModel(&#10;    private val backend: ChatBackend,&#10;    private val apiKeyPresent: Boolean&#10;) : ViewModel() {&#10;&#10;    private val _messages = MutableStateFlow&lt;List&lt;ChatMessage&gt;&gt;(emptyList())&#10;    val messages: StateFlow&lt;List&lt;ChatMessage&gt;&gt; = _messages.asStateFlow()&#10;&#10;    private val _sending = MutableStateFlow(false)&#10;    val sending: StateFlow&lt;Boolean&gt; = _sending.asStateFlow()&#10;&#10;    private val _error = MutableStateFlow&lt;String?&gt;(null)&#10;    val error: StateFlow&lt;String?&gt; = _error.asStateFlow()&#10;&#10;    private var counter = 0L&#10;&#10;    init {&#10;        if (!apiKeyPresent) {&#10;            appendSystem(&quot;Chat service key missing. Responses are lightweight local hints only.&quot;)&#10;        } else {&#10;            appendSystem(&quot;Chat assistant ready. This overlay is temporary and not persisted.&quot;)&#10;        }&#10;    }&#10;&#10;    private fun nextId() = ++counter&#10;&#10;    private fun append(role: ChatMessage.Role, text: String) {&#10;        _messages.value = _messages.value + ChatMessage(nextId(), role, text)&#10;    }&#10;&#10;    private fun appendSystem(text: String) = append(ChatMessage.Role.System, text)&#10;&#10;    fun send(userInput: String) {&#10;        val trimmed = userInput.trim()&#10;        if (trimmed.isEmpty() || _sending.value) return&#10;        append(ChatMessage.Role.User, trimmed)&#10;        _sending.value = true&#10;        _error.value = null&#10;        viewModelScope.launch {&#10;            try {&#10;                val reply = backend.sendMessage(trimmed)&#10;                append(ChatMessage.Role.Assistant, reply)&#10;            } catch (t: Throwable) {&#10;                _error.value = t.message ?: t::class.simpleName ?: &quot;error&quot;&#10;                append(ChatMessage.Role.System, &quot;Error: ${_error.value}&quot;)&#10;            } finally {&#10;                _sending.value = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun clearError() { _error.value = null }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>